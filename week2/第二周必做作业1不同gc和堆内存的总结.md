在1G初始内存和最大内存，忽略自适应情况下 测试gateway-server-0.0.1-SNAPSHOT.jar的gc情况情况，压测开了40个线程，30秒时间内
分别得到jar包启动后gc情况，压测后gc情况，和压测30秒内的总处理请求数，rps和一定占比请求的处理时间
下图为压测前jstat -gcutil 进程id  1000 5
	  压测后jstat -gcutil 进程id  1000 5
	  和压测的总处理请求数，RPS，和百分之50	90	99	99.9的处理时间
			ygc			YGCT				FGC			FGCT		FCT		       50		90		99		99.9	总处理数	rps				
serialgc																	       0		8		29		55		79032		2546	
压测前   	3			57   				1			80			80             
压测后   	10			89					2			101			189            
parallelGC																	       0		7		25		52		88292		2834
压测前 		3			40					2			92			132            
压测后		12			84					2			92			176            
cmsGC																		       0		8		27		66		81707		2627						
压测前 		2			27					2			21			48             
压测后		10			110					2			21			131		       
g1GC(未设置MaxGCPauseMillis   )												       0		9		27		59		76341		2448
压测前 		3			21					0			0			21             
压测后		7			94					0			0			94             
一共76341	rps 2448                                                               
G1GC(-XX:MaxGCPauseMillis=50)												       0		9		27		55		75223		2410
压测前 		6			47					0			0			47             
压测后		11			79					0			0			79

虽然测试次数只有一次，而且可能受网络延迟和cpu的影响，但是通过上面的数据还是能够得到一定的信息
第一：通过fullgc次数可以发现，除了g1gc外，其他垃圾回收器都有2次fullgc，所以可以得出g1gc通过与其他垃圾回收器不同的分区思想，可以减少fullgc的次数，
第二：通过gc总时间可以得出：
		1.串行gc由于单核处理，所以总时间最长，
		2.parallelgc因为注重高吞吐，所以垃圾回收总的时间也很长，
		3.cmsgc是并发gc，注重低延迟，又因为使用了标记清除算法，省去了压缩整理的时间，所以单次fullgc的时间很短，2次只花了21ms，作为对比，serialgc和paralgc
		  的单次fullgc时间为50ms和46ms，当然当程序运行时间更久，数据量更大的情况下，cms的总gc时间会超过parallelgc，因为cms单次gc时间短，但是因为gc次数多
		  总的gc时间会很高
		4.g1gc在指定期望达到的最大gc停顿时间后，gc的频率变多，单次gc的时间变少,gc总时间变少（大数据量下gc总时间会变多）
第三：通过压测数据可以发现
		1.parallelgc注重吞吐量，所以总处理数最多，rps也最多，
		2.g1GC设置了-XX:MaxGCPauseMillis=50这个参数后，虽然百分之99的请求处理时间还是在55毫秒超过了50毫秒，但是比没有设置这个参数时，99%的处理时间快了4ms，说明
		  参数发挥了作用
		3.serialgc因为是串行，所以处理量不如并行的ParNew\cmsgc